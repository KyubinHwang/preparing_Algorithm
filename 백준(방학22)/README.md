# 1987번 알파벳

## - 문제
세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.

입력

첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.

출력

첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.
## - 풀이 방법
백트래킹을 이용한 문제로 알파벳 갯수 만큼의 bool check 변수를 이용하여 지나가지 않은 알파벳의 최대 수를 확인하는 문제였다. char형의 이차원 배열을 선언하여 string의 문자열을 이용하여 배열을 입력받은 후, check[v[x][y] - 65] = true; 처럼 아스키코드를 이용한 알파벳의 순서에 따른 인덱스의 bool값을 true 또는 false로 바꿔주어서 지나온 알파벳의 위치를 나타내어 주었다.

이 때 int dx[4] = { 1,-1,0,0 }, dy[4] = { 0,0,1,-1 }; 와 같이 상하 좌우의 좌표를 표현하여 알파벳들을 이동하면서 지나온 자리를 중복하지 않고 넘어가지 않도록 설정하고 재귀함수를 이용한 백트래킹을 통해 최대 깊이로 진행하였을 때가 알파벳의 최대 칸수를 구할 수 있었다.

    for (int i = 0; i < 4; i++) {
        int x2 = x + dx[i];
        int y2 = y + dy[i];

        if (x2 >= 0 && x2 < R && y2 >= 0 && y2 < C && !check[v[x2][y2] - 65]) {
          board(x2, y2, dept + 1);
          check[v[x2][y2] - 65] = false;
        }
      }
