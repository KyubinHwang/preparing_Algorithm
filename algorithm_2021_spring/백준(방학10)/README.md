# 6603번 로또

## - 문제
독일 로또는 {1, 2, ..., 49}에서 수 6개를 고른다.

로또 번호를 선택하는데 사용되는 가장 유명한 전략은 49가지 수 중 k(k>6)개의 수를 골라 집합 S를 만든 다음 그 수만 가지고 번호를 선택하는 것이다.

예를 들어, k=8, S={1,2,3,5,8,13,21,34}인 경우 이 집합 S에서 수를 고를 수 있는 경우의 수는 총 28가지이다. ([1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], ..., [3,5,8,13,21,34])

집합 S와 k가 주어졌을 때, 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오.

입력

입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 수는 k (6 < k < 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다.

입력의 마지막 줄에는 0이 하나 주어진다. 

출력

각 테스트 케이스마다 수를 고르는 모든 방법을 출력한다. 이때, 사전 순으로 출력한다.

각 테스트 케이스 사이에는 빈 줄을 하나 출력한다.

## - 풀이 방법
백트래킹 문제였고 깊이를 설정해서 로또의 길이인 6을 도달하면 그 로또 번호를 출력하고 다시 되돌아가는 방식을 이용하였다.

로또 번호를 저장하는 vector S를 선언하고 k의 크기로 설정하였다. lotto라는 함수를 만들었는데 이는 매개변수로 s의 인덱스를 지정하는 n과 현재 로또의 깊이를 나타내는 dept, 그리고 vector S 세가지를 선언하였다. 처음 시작은 lotto(0, 0, S)로 S에 저장된 로또 번호 0부터 시작하여 로또 번호를 찾아갔다.

lotto함수에서는 먼저 dept 로또의 길이가 6에 도달하면 로또 번호를 출력하는 함수 printing을 출력하고 재귀를 빠져나오게 하였고, 아직 길이가 6이 아니라면 lottonum이라는 로또번호를 저장하는 벡터에 현재 dept에 맞는 인덱스에 S에 저장된 로또 번호를 저장 시켰다. 그리고 현재 인덱스 다음에 로또번호를 찾기위해 lotto(i + 1, dept + 1, S)와 같은 방식으로 재귀를 진행하였다.

    void lotto(int n, int dept, vector <int> S) {

      if (dept == 6) {
        printing();
        return;
      }

      for (int i = n; i < k; i++) {
        lottonum[dept] = S[i];
        lotto(i + 1, dept + 1, S);
      }
    }
    
위 함수를 이용하여 로또번호를 백트래킹으로 찾아줄 수 있었다.
